<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>USCSS PORTFOLIO</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: #0a0a0a; overflow: hidden; font-family: 'Courier New', monospace; cursor: none; }
    #app { width: 100vw; height: 100vh; position: relative; }

    /* Cursor */
    #cursor { position: fixed; width: 20px; height: 20px; border-radius: 50%;
      border: 2px solid #00ff41; box-shadow: 0 0 10px #00ff41, inset 0 0 10px #00ff41;
      pointer-events: none; z-index: 10000; transition: transform 60ms linear; }

    /* CRT overlay */
    #crt { position: fixed; inset: 0; pointer-events: none; z-index: 9999;
      background: repeating-linear-gradient(0deg, rgba(255,255,255,0.06) 0px, rgba(255,255,255,0.06) 1px, transparent 1px, transparent 3px);
      animation: flicker 0.2s infinite; }
    #crt::before { content: ""; position: absolute; inset: 0; pointer-events: none;
      box-shadow: inset 0 0 220px 80px rgba(0,0,0,0.85); }
    @keyframes flicker { 0%,100% { opacity: .97 } 50% { opacity: 1 } }

    /* HUD */
    .hud { position: fixed; color: #00ff41; text-shadow: 0 0 5px #00ff41; z-index: 100; letter-spacing: 2px; font-size: 12px; }
    .tl { top: 20px; left: 20px; }
    .tr { top: 20px; right: 20px; text-align: right; }
    .bl { bottom: 20px; left: 20px; }
    .bc { bottom: 40px; left: 50%; transform: translateX(-50%); opacity: .7; text-align: center; }
    .mode { font-size: 24px; letter-spacing: 4px; margin-bottom: 6px; }

    /* Loading */
    #loading { position: fixed; inset: 0; background:#0a0a0a; color:#00ff41; display:flex; align-items:center; justify-content:center; flex-direction:column; z-index:10001; text-shadow:0 0 8px #00ff41; }
    #loading .bar { width: 300px; height: 4px; border:1px solid #00ff41; background:#001a00; overflow:hidden; }
    #loading .fill { height:100%; background:#00ff41; box-shadow:0 0 10px #00ff41; animation: load 1.2s ease-in-out forwards; }
    @keyframes load { from{width:0%} to{width:100%} }
  </style>
</head>
<body>
  <!-- Loading -->
  <div id="loading">
    <div style="margin-bottom:14px; letter-spacing:3px">INITIALIZING SYSTEM...</div>
    <div class="bar"><div class="fill"></div></div>
  </div>

  <!-- UI -->
  <div id="cursor"></div>
  <div id="crt"></div>

  <div class="hud tl">
    <div class="mode" id="modeDisplay">CLIENTS</div>
    <div>SYS: OPERATIONAL</div>
    <div>PWR: █ NOMINAL</div>
  </div>
  <div class="hud tr">
    <div>WEYLAND-YUTANI CORP</div>
    <div>USCSS PORTFOLIO</div>
    <div>ID: <span id="ts"></span></div>
  </div>
  <div class="hud bl">
    <div>CURSOR: <span id="xy">X:0 Y:0</span></div>
    <div>MODE: NAVIGATION</div>
  </div>
  <div class="hud bc">MOVE CURSOR TO ROTATE // CLICK TO ACCESS</div>

  <div id="app"></div>

    <audio id="hum" src="uscss-sitesounds/ship_hum.mp3" loop></audio>
    <audio id="blip" src="uscss-sitesounds/Flick.mp3"></audio>

  <!-- Three.js CDN -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>

  <script>
    const humEl = document.getElementById('hum');
const blipEl = document.getElementById('blip');

// --- HUM: start on first user interaction ---
humEl.volume = 0.25;

function startHum() {
  // guard so it only starts once
  if (humEl.dataset.started) return;
  humEl.dataset.started = "1";
  humEl.muted = false;           // make sure it's not muted
  humEl.currentTime = 0;         // restart from beginning
  humEl.play().catch(() => {
    // If this fails, browser didn't count the gesture—pointer/keydown below will try again.
  });
}

// Start hum on first click/tap/keypress anywhere
window.addEventListener('pointerdown', startHum, { once: true });
window.addEventListener('keydown', startHum, { once: true });


// iOS/Chrome will block audio until user interacts.
// We'll start the hum on the first click.
function ensureAudio(){
  if (humEl.dataset.started) return;
  humEl.volume = 0.10; // comfy level
  humEl.play().then(()=>{
    humEl.dataset.started = "1";
  }).catch(()=>{/* ignore until next click */});
}

function playBlip(){
  // rewind so it can play rapidly
  blipEl.currentTime = 0;
  blipEl.volume = 0.5;
  blipEl.play().catch(()=>{});
}

function onClick(){
  startHum();    // <- ensure hum begins
  playBlip();    // <- your blip

  const dest = isClients ? 'clients.html' : 'personal.html';
  setTimeout(() => { location.href = dest; }, 150); // tiny delay so audio isn't cut off
}


    // Cursor + timestamp
    const cursorEl = document.getElementById('cursor');
    const tsEl = document.getElementById('ts');
    const xyEl = document.getElementById('xy');
    const modeDisplay = document.getElementById('modeDisplay');

    document.addEventListener('mousemove', (e) => {
      cursorEl.style.transform = `translate(${e.clientX - 10}px, ${e.clientY - 10}px)`;
      xyEl.textContent = `X:${e.clientX} Y:${e.clientY}`;
    });
    function tickTS(){
      const d=new Date();
      tsEl.textContent = `${d.getFullYear()}.${String(d.getMonth()+1).padStart(2,'0')}.${String(d.getDate()).padStart(2,'0')}`;
    }
    tickTS(); setInterval(tickTS, 1000);

    // Three.js
    let scene, camera, renderer, textMesh, particles;
    let mouseX=0, mouseY=0; // -1..1 normalized
    let isClients=true; let t=0;

    function init(){
      const w=innerWidth, h=innerHeight;
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x0a0a0a, 10, 60);

      camera = new THREE.PerspectiveCamera(60, w/h, 0.1, 200);
      camera.position.set(0,1.2,15);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(w,h);
      renderer.setClearColor(0x0a0a0a, 1);
      document.getElementById('app').appendChild(renderer.domElement);

      // Lights
      scene.add(new THREE.AmbientLight(0x00ff41, 0.25));
      const key=new THREE.PointLight(0x00ff41, 2.2, 100); key.position.set(3,4,6); scene.add(key);

      // Back planet
      const planet = new THREE.Mesh(
        new THREE.SphereGeometry(3.2,64,64),
        new THREE.MeshStandardMaterial({ color:'#0b1d1a', roughness:0.9, metalness:0.05, emissive:'#061b14', emissiveIntensity:0.2 })
      );
      planet.position.set(0,-1.8,-10); scene.add(planet);

      // Stars
      const starGeo = new THREE.BufferGeometry();
      const count = 900; const pos = new Float32Array(count*3);
      for(let i=0;i<count;i++){ pos[i*3+0]=(Math.random()-0.5)*80; pos[i*3+1]=(Math.random()-0.5)*40; pos[i*3+2]=(Math.random()-0.5)*80; }
      starGeo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
      const starMat = new THREE.PointsMaterial({ color:0x00ff41, size:0.08, opacity:0.6, transparent:true });
      particles = new THREE.Points(starGeo, starMat); scene.add(particles);

      // Text plane
      textMesh = new THREE.Mesh(new THREE.PlaneGeometry(20,5), new THREE.MeshBasicMaterial({transparent:true}));
      scene.add(textMesh);
      drawText('CLIENTS');

      // events
      addEventListener('resize', onResize);
      addEventListener('mousemove', onMouseMove);
      addEventListener('click', onClick);

      // hide loading
      setTimeout(()=>{ const l=document.getElementById('loading'); l.style.opacity='0'; setTimeout(()=>l.remove(), 300); }, 900);

      animate();
    }

    function drawText(text, glitch=false){
  const canvas=document.createElement('canvas');
  const ctx=canvas.getContext('2d');
  canvas.width=1024; canvas.height=256;

  // bg
  ctx.fillStyle='#0a0a0a'; ctx.fillRect(0,0,canvas.width,canvas.height);

  // font
  ctx.font='bold 120px Courier New';
  ctx.textAlign='center';
  ctx.textBaseline='middle';

  if(glitch){
    // RGB split + per-letter wobble
    const off = (Math.random()*20 - 10) | 0;
    ctx.fillStyle='#ff0044'; ctx.fillText(text, canvas.width/2 + off, canvas.height/2);
    ctx.fillStyle='#0044ff'; ctx.fillText(text, canvas.width/2 - off, canvas.height/2);
    ctx.fillStyle='#00ff41';
    const chars = text.split('');
    let x = canvas.width/2 - chars.length*35;
    for(let i=0;i<chars.length;i++){
      const yoff = (Math.random()*10 - 5) | 0;
      ctx.fillText(chars[i], x + i*70 + Math.random()*4, canvas.height/2 + yoff);
    }
  } else {
    ctx.fillStyle='#00ff41';
    ctx.fillText(text, canvas.width/2, canvas.height/2);
  }

  // scanlines
  for(let i=0;i<canvas.height;i+=4){
    ctx.fillStyle='rgba(0,0,0,0.1)';
    ctx.fillRect(0,i,canvas.width,2);
  }

  const tex=new THREE.CanvasTexture(canvas); tex.needsUpdate=true;
  textMesh.material.map=tex; textMesh.material.needsUpdate=true;
}

    function onMouseMove(e){
  const w=innerWidth, h=innerHeight;
  mouseX = (e.clientX/w)*2 - 1;
  mouseY = -(e.clientY/h)*2 + 1;

  const wasClients = isClients;
  isClients = mouseX < 0; // left = clients, right = personal
  if(wasClients !== isClients){
    const label = isClients ? 'CLIENTS' : 'PERSONAL';
    modeDisplay.textContent = label;
    drawText(label, true);    // glitch burst
    setTimeout(() => drawText(label, false), 80); // settle back
    playBlip();               // small UI blip sound (next step)
  }
}


    function onClick(){
      const dest = isClients ? 'clients.html' : 'personal.html';
      
       location.href = dest;
      alert((isClients ? 'CLIENTS' : 'PERSONAL') + ' clicked. Create ' + dest + ' to enable navigation.');
    }

    function animate(){
      requestAnimationFrame(animate);

      // parallax
      scene.rotation.y += ((mouseX*0.35) - scene.rotation.y)*0.05;
      scene.rotation.x += ((-mouseY*0.15) - scene.rotation.x)*0.05;

      // follow & pulse
      if(textMesh){
        textMesh.position.x += ((mouseX*2) - textMesh.position.x)*0.05;
        textMesh.position.y += ((mouseY*2) - textMesh.position.y)*0.05;
        t += 0.02; const s = 1 + Math.min(Math.hypot(mouseX,mouseY)*0.3,0.25) + Math.sin(t)*0.01;
        textMesh.scale.set(s,s,1);
      }

      if(particles){ particles.rotation.y += 0.0008; particles.rotation.x += 0.0003; }
      renderer.render(scene, camera);
    }

    function onResize(){
      const w=innerWidth, h=innerHeight;
      camera.aspect=w/h; camera.updateProjectionMatrix();
      renderer.setSize(w,h);
    }

    init();
  </script>

</body>
</html>
